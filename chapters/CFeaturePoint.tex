% !TeX root = ../main.tex
\chapter{特征点的提取与匹配}
\section{图像特征介绍}
图像匹配技术是计算机视觉领域的技术重要组成之一。图像匹配这项技术主要应用于目标识别、图像拼接、自动跟踪定位等研究。而基于特征点的图像匹配则是一种十分有效的方法。进行特征匹配的话，一般分为三个步骤，特征提取、特征描述和特征匹配。具体就是通过检测关键点，然后提取描述向量，最后来建立局部特征描述子，再进行特征匹配的过程。
\section{特征检测子}
\subsection{Harris 角点检测}
角点往往是两条边缘的交点，它是两条边缘方向变换的一种表示，因此其两个方向的梯度变换通常都比较大并且容易检测到。这里我们理解一下角点检测的算法。\par
\subsubsection{角点检测基本原理：}\par
人们通常通过在一个小的窗口区域内观察点的灰度值大小来识别角点，如果往任何方向移动窗口都会引起比较大的灰度变换那么往往这就是我们要找的角点。如下图:\par
\begin{figure}
\centering
\includegraphics[height=5cm]{figures/Harris1.png}
\caption{角点的选择}
\end{figure}
\subsubsection{角点检测基本流程}
使用角点检测算子，对图像的每个像素计算角点响应函数(Corner Response Function )，阈值化角点响应函数，根据实际情况选择阈值，对阈值化的角点响应函数进行非极大值抑制，并获取非零点作为角点。
\subsubsection{Harris角点\cite{harris1988combined}}
下面我们看一下Harris的数学公式:
\begin{equation}
E(u,v)=\sum_{x}\sum_{y} w(x,y)[I(x+u,y+v)-I(x,y)]^{2}\label{Harris}
\end{equation}\par
式中$E(u,v)$即为角点响应函数，事实上被叫做窗口响应函数可能更合适，因为实际上$E(u,v)$计算的是一个5\times5或者7\times7的窗口。$x,y$为要计算的像素点。$I(x,y)$为该点的灰度值。$w(x,y)$为窗函数，可以理解为每个像素点的加权系数。
\begin{figure}
	\centering
	\includegraphics[height=3cm]{figures/Harris2.png}
	\caption{窗口函数}
\end{figure}
可以想象的到，对于平滑的，灰度值相对稳定的区域，该响应函数趋近于0；对于边缘区域，该响应函数在垂直于边缘方向上响应大，平行于边缘区域响应小；对于角点区域，无论什么方向响应都很大。道理是这个道理，但是给定上面的式子，变化u，v时，我们不能很直观的看出$E(u,v)$的变化。所以，我们要对上式进行一些变化和近似。使用泰勒级数展开，并忽略非线性项:
\begin{equation}
\begin{aligned}
I(x+u, y+v) &\approx I(x, y)+u I_{x}+v I_{y}+\omicron\left(I_x^{2},I_y^{2}\right)\\
&=I(x, y)+u I_{x}+v I_{y}
\end{aligned}
\end{equation}\par
由于图像的检测算子都很小，对上式做泰勒一阶展开是合理的，故响应函数可化为:
\begin{equation}
\begin{aligned}
E(u,v)=&\sum_{x,y} w(x,y) [I(x+u, y+v)-I(x, y)]^{2} \\
\approx&\sum_{x,y}w(x,y)\left[I(x, y)+u I_{x}+v I_{y}-I(x, y)\right]^{2}\\
=&\sum_{x,y}w(x,y) \left(u^{2} I_{x}^{2}+2 u v I_{x} I_{y}+v^{2} I_{y}^{2} \right)\\
=&\sum_{x,y}w(x,y) \left[ \begin{array}{cc}{u} & {v}\end{array}\right] \left[ \begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\ 
{I_{x} I_{y}} & {I_{y}^{2}}\end{array}\right] \left[ \begin{array}{c}{u} \\ 
{v}\end{array}\right]\\
=&\left[ \begin{array}{cc}{u} & {v}\end{array}\right]M\left[\begin{array}{c}{u}\\{v}\end{array}\right]
\end{aligned}
\end{equation}
其中:
\begin{equation}
M=\sum_{x, y} w(x, y) \left( \begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\ {I_{x} I_{y}} & {I_{y}^{2}}\end{array}\right)=\left( \begin{array}{cc}{\sum_{W} I_{x}^{2}} & {\sum_{W} I_{x} I_{y}} \\ {\sum_{W} I_{x} I_{y}} & {\sum_{W} I_{y}^{2}}\end{array}\right)=\left[ \begin{array}{cc}{A} & {C} \\ {C} & {B}\end{array}\right]
\end{equation}
故:
\begin{equation}
	E(u,v) \approx Au^{2}+2Cuv+Bv^{2}
\end{equation}
由公式\ref{Harris}可以看到，这样的函数在三维空间上起码是非负定的，如图\ref{ercixing}所示：
\begin{figure}
\includegraphics[height=5cm]{figures/ercixing.png}
\includegraphics[height=5cm]{figures/ercixing1.png}
\caption{$E(u,v)$图像}
\label{ercixing}
\end{figure}\\
因此问题就变成了究竟怎样形式的E(u,v)的图像，才能算作一个特征点。直观上讲，一个角点应该无论在哪个方向上，响应函数$E$都应有一个大的变化。我们的也可以这么说：为了使响应函数$E$在角点邻域内有较大的变化量，M应该有两个较大的特征值。论文\cite{harris1988combined}指出，二次型矩阵的两个特征值$\lambda_1$和$\lambda_2$与点邻域的性质有如下关系:
\begin{itemize}
	\item 若$\lambda_1 \approx 0$，$\lambda_2\approx 0$，则表示图像在此处变化不大；
	
	\item 若$\lambda_1 \approx 0$且$\lambda_2$具有很大的正值，则表示检测到了边缘；
	
	\item 若$\lambda_1$，$\lambda_2$都很大，则表示检测到了角点；
\end{itemize}
但是实际在应用中，由于计算特征值比较慢，我们转而计算函数$R$来得到结果。其中$\kappa$是灵敏度系数，$\kappa$越小越敏感，一般来说$\kappa=0.04$。
\begin{equation}
	R = \lambda_1\lambda_2-\kappa(\lambda_1+\lambda_2)^2=det(M)-\kappa trace^2(M)
\end{equation}
因此，算法并不直接计算特征值，而是通过矩阵的行列式和迹来测量角点，从而大大提高了计算效率。\par
算法在计算完图像中的角点之后，图像上某些区域可能会出现角点十分密集的情况，这时候就要进行\textbf{非最大值抑制(Non-maximal Suppression)}。也就是说只保留局部区域中响应最大的特征点，从而避免匹配的时候重复检测。\par
\begin{figure}
	\includegraphics[height=5cm]{figures/LoG1.png}
	\includegraphics[height=5cm]{figures/LoG2.png}
	\caption{Harris角点不具有尺度不变性}
	\label{HarrisScale}
\end{figure}
这样，基于Harris角点的特征点检测方法已经介绍完了，但是这种角点并不完美。最大的问题就是Harris角点的检测窗口大小是固定的，也就是说Harris角点不具有尺度不变性。如图\ref{HarrisScale}可以看出来。左侧图像期望一个小的检测窗口，而右侧图像期待一个大的检测窗口。显然，在尺度变化较大的图像中，Harris角点并不能胜任检测工作，由此我们引出基于LoG的多尺度特征检测子。\par

\subsection{基于LoG的多尺度特征检测子}
\subsubsection{Laplace算子}
Laplace算子简单来说是两个梯度算子的点乘:
\begin{equation*}
\triangle=\nabla \cdot \nabla=\nabla^{2}=\left[\frac{\partial}{\partial x_{1}}, \cdots, \frac{\partial}{\partial x_{N}}\right] \left[ \begin{array}{c}{\frac{\partial}{\partial x_{1}}} \\ {\vdots} \\ {\frac{\partial}{\partial x_{N}}}\end{array}\right]=\sum_{n=1}^{N} \frac{\partial^{2}}{\partial x_{n}^{2}}
\end{equation*}
对于图像处理来说，一般用到的是二维的Laplace算子:
\begin{equation*}
\triangle=\nabla \cdot \nabla=\nabla^{2}=\left[\frac{\partial}{\partial x} \frac{\partial}{\partial y}\right] \left[ \begin{array}{c}{\frac{\partial}{\partial x}} \\ {\frac{\partial}{\partial y}}\end{array}\right]=\frac{\partial^{2}}{\partial x^{2}}+\frac{\partial^{2}}{\partial y^{2}}
\end{equation*}
对于函数$f(x,y)$应用Laplace算子:
\begin{equation*}
\triangle f(x, y)=\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}}
\end{equation*}
对于离散的情况，二阶微分就变成了二阶差分。\par
我们先来看看在一维情况下将一阶差分：
\begin{equation*}
\nabla f[n]=f[n+1]-f[n]
\end{equation*}
那么一维的二阶差分就是:
\begin{equation*}
	\begin{aligned}
	\triangle f[n]=&\nabla(\nabla f[n])=\nabla f[n]-\nabla f[n-1]\\
	=&(f[n+1]-f[n])-(f[n]-f[n-1])\\
	=&f[n+1]-2 f[n]+f[n-1]
	\end{aligned}
\end{equation*}
因此，在一维情况下，Laplace算子可以理解成一维的卷积，其卷积核是$[1,-2,1]$。\par
在二维情况下，Laplace算子是两个维度中两个二阶差分的总和:
\begin{equation}
\begin{aligned}
\triangle f[m, n]=&\triangle_{m}[f[m, n]]+\triangle_{n}[f[m, n]]\\
=&f[m+1, n]-2 f[m, n]+f[m-1, n]+f[m, n+1]-2 f[m, n]+f[m, n-1]\\
=&f[m+1, n]+f[m-1, n]+f[m, n+1]+f[m, n-1]-4 f[m, n]
\end{aligned}
\end{equation}
此操作也可以理解成二维的卷积，其卷积核是:
\begin{equation*}
\left[ \begin{array}{lll}{0} & {1} & {0} \\ {1} & {-4} & {1} \\ {0} & {1} & {0}\end{array}\right]
\end{equation*}
\subsubsection{LoG算子}
图像中的噪声和边缘一样会使图像产生灰度跳变，我们在使用Laplace算子检测边缘细节的同时，往往也增强了噪声，因此，如何区分开噪声和边缘是个问题。\par
为了在取得较好的检测同时把噪声干扰降到最低，可以先对有噪声的原始图像进行平滑滤波，然后再进行锐化处理增强边缘和细节。基于这一思想，Marr和Hildreth\cite{marr1980theory}提出了把高斯平滑算子和拉普拉斯锐化算子结合起来的方法，称之为拉普拉斯-高斯(LoG)算子。\par
高斯平滑算子:
\begin{equation}
G_{\sigma}(x, y)=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp \left(-\frac{x^{2}+y^{2}}{2 \sigma^{2}}\right)
\end{equation}\par
LoG算子:
\begin{equation}
\triangle\left[G_{\sigma}(x, y) * f(x, y)\right]=\left[\triangle G_{\sigma}(x, y)\right] * f(x, y)=L o G * f(x, y)
\\
\end{equation}
\begin{equation}
\begin{aligned}
L o G \triangleq& \triangle G_{\sigma}(x, y)=\frac{\partial^{2}}{\partial x^{2}} G_{\sigma}(x, y)+\frac{\partial^{2}}{\partial y^{2}} G_{\sigma}(x, y)\\
=&\frac{x^{2}+y^{2}-2 \sigma^{2}}{\sigma^{4}} \exp \left(-\frac{x^{2}+y^{2}}{2 \sigma^{2}}\right)
\end{aligned}
\end{equation}\par
画出LoG算子的空间形状：
\begin{figure}
	\centering
	\begin{subfigure}[ht]{0.3\textwidth}
		\centering
		\includegraphics[height=0.7\textwidth]{figures/LoG_plot.png}
		\subcaption{连续空间表示}
	\end{subfigure}
\qquad \qquad \qquad
	\begin{subfigure}[ht]{0.3\textwidth}
		\centering
		\includegraphics[height=0.7\textwidth]{figures/LoG_table}
		\subcaption{离散空间表示}
	\end{subfigure}
\caption{LoG算子空间表示}
\end{figure}
\begin{figure}
\centering
\includegraphics[height=4cm]{figures/LoG.png}
\caption{左:LoG算子\qquad \qquad \qquad \qquad 右:Laplace算子}
\end{figure}\par
可以看到，LoG算子显著减小了噪点对检测的影响。
\subsubsection{尺度空间}












\subsection{基于DoG的多尺度特征检测子}
\subsection{快速特征点检测方法}